name: Complete Deployment Pipeline

on:
  workflow_dispatch:
  push:
    branches: [ infra/main, infra/develop ]
    paths:
      - "infrastructure/**"
      - "microservices/**"
  pull_request:
    branches: [ infra/main, infra/develop ]
    paths:
      - "infrastructure/**"
      - "microservices/**"

jobs:
  terraform-dev:
    runs-on: ubuntu-latest
    outputs:
      acr_name: ${{ steps.terraform-output.outputs.acr_name }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.13.1"

      - name: Terraform Init (dev)
        working-directory: infrastructure/terraform/environments/dev
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          terraform init \
          -backend-config="resource_group_name=terraform-state-rg" \
          -backend-config="storage_account_name=msworkshop1tfstate" \
          -backend-config="container_name=tfstate-dev" \
          -backend-config="key=dev/terraform.tfstate"

      - name: Terraform Plan (dev)
        working-directory: infrastructure/terraform/environments/dev
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: terraform plan -var="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" -out=tfplan

      - name: Terraform Apply with Auto-Import (dev)
        shell: pwsh
        working-directory: infrastructure/terraform/environments/dev
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: terraform apply -auto-approve tfplan
  build-and-push:
    runs-on: ubuntu-latest
    needs: terraform-dev
    steps:
      - uses: actions/checkout@v4

      - name: Build and Push Docker Images
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          # AZURE_IP se obtendrá en runtime durante el deploy
          AUTH_API_PORT: ${{ vars.AUTH_API_PORT }}
          TODOS_API_PORT: ${{ vars.TODOS_API_PORT }}
          USERS_API_PORT: ${{ vars.USERS_API_PORT }}
          FRONTEND_PORT: ${{ vars.FRONTEND_PORT }}
          REDIS_HOST: ${{ vars.REDIS_HOST }}
          REDIS_PORT_TODOS: ${{ vars.REDIS_PORT_TODOS }}
          REDIS_PORT_LOG: ${{ vars.REDIS_PORT_LOG }}
          REDIS_CHANNEL: ${{ vars.REDIS_CHANNEL }}
          ZIPKIN_HOST: ${{ vars.ZIPKIN_HOST }}
          ZIPKIN_PORT: ${{ vars.ZIPKIN_PORT }}
          ZIPKIN_URL: ${{ vars.ZIPKIN_URL }}
          USERS_API_URL: ${{ vars.USERS_API_URL }}
        run: |
          az login --service-principal \
            --username ${{ secrets.AZURE_CLIENT_ID }} \
            --password ${{ secrets.AZURE_CLIENT_SECRET }} \
            --tenant ${{ secrets.AZURE_TENANT_ID }}
          az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ACR_NAME="msworkshop1devacr"
          ACR_LOGIN_SERVER=$ACR_NAME.azurecr.io
          az acr login --name $ACR_NAME
          # Build images with placeholder for AZURE_IP (will be replaced during deployment)
          declare -a images=("log-message-processor" "auth-api" "frontend" "todos-api" "users-api")
          for img in "${images[@]}"; do
            docker build -t $img:latest ./microservices/$img \
              --build-arg JWT_SECRET=$JWT_SECRET \
              --build-arg AZURE_IP=PLACEHOLDER_AZURE_IP \
              --build-arg AUTH_API_PORT=$AUTH_API_PORT \
              --build-arg TODOS_API_PORT=$TODOS_API_PORT \
              --build-arg USERS_API_PORT=$USERS_API_PORT \
              --build-arg FRONTEND_PORT=$FRONTEND_PORT \
              --build-arg REDIS_HOST=$REDIS_HOST \
              --build-arg REDIS_PORT_TODOS=$REDIS_PORT_TODOS \
              --build-arg REDIS_PORT_LOG=$REDIS_PORT_LOG \
              --build-arg REDIS_CHANNEL=$REDIS_CHANNEL \
              --build-arg ZIPKIN_HOST=$ZIPKIN_HOST \
              --build-arg ZIPKIN_PORT=$ZIPKIN_PORT \
              --build-arg ZIPKIN_URL=$ZIPKIN_URL \
              --build-arg USERS_API_URL=$USERS_API_URL
            docker tag $img:latest $ACR_LOGIN_SERVER/$img:latest
            docker push $ACR_LOGIN_SERVER/$img:latest
          done

  deploy-kubernetes:
    runs-on: ubuntu-latest
    needs: [ terraform-dev, build-and-push ]
    steps:
      - uses: actions/checkout@v4

      - name: Get AKS Credentials
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          az login --service-principal \
            --username ${{ secrets.AZURE_CLIENT_ID }} \
            --password ${{ secrets.AZURE_CLIENT_SECRET }} \
            --tenant ${{ secrets.AZURE_TENANT_ID }}
          az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          az aks get-credentials \
          --resource-group msworkshop1-dev-rg \
          --name msworkshop1-dev-aks

      - name: Wait for LoadBalancer IP and Update Environment
        id: get-ip
        run: |
          echo "Waiting for nginx-ingress LoadBalancer to get external IP..."
          for i in {1..20}; do
            EXTERNAL_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [[ -n "$EXTERNAL_IP" && "$EXTERNAL_IP" != "null" ]]; then
              echo "Found external IP: $EXTERNAL_IP"
              echo "AZURE_IP=$EXTERNAL_IP" >> $GITHUB_ENV
              echo "azure_ip=$EXTERNAL_IP" >> $GITHUB_OUTPUT
              break
            fi
            echo "Attempt $i: External IP not ready yet, waiting 30 seconds..."
            sleep 30
          done

          if [[ -z "$EXTERNAL_IP" || "$EXTERNAL_IP" == "null" ]]; then
            echo "Error: Could not obtain external IP after 10 minutes"
            exit 1
          fi

      - name: Deploy to Kubernetes
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          # AZURE_IP se obtiene dinámicamente del step anterior
          AUTH_API_PORT: ${{ vars.AUTH_API_PORT }}
          TODOS_API_PORT: ${{ vars.TODOS_API_PORT }}
          USERS_API_PORT: ${{ vars.USERS_API_PORT }}
          FRONTEND_PORT: ${{ vars.FRONTEND_PORT }}
          REDIS_HOST: ${{ vars.REDIS_HOST }}
          REDIS_PORT_TODOS: ${{ vars.REDIS_PORT_TODOS }}
          REDIS_PORT_LOG: ${{ vars.REDIS_PORT_LOG }}
          REDIS_CHANNEL: ${{ vars.REDIS_CHANNEL }}
          ZIPKIN_HOST: ${{ vars.ZIPKIN_HOST }}
          ZIPKIN_PORT: ${{ vars.ZIPKIN_PORT }}
          ZIPKIN_URL: ${{ vars.ZIPKIN_URL }}
          USERS_API_URL: ${{ vars.USERS_API_URL }}
        run: |
          ACR_NAME="msworkshop1devacr"
          ACR_LOGIN_SERVER=$ACR_NAME.azurecr.io
          export ACR_LOGIN_SERVER
          echo "Using dynamic AZURE_IP: $AZURE_IP"
          find ./deployment/kubernetes/dev -name "*.yaml" -o -name "*.yml" | while read manifest; do
            envsubst < $manifest | kubectl apply -f -
          done

      - name: Rebuild Frontend with Real IP
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          AUTH_API_PORT: ${{ vars.AUTH_API_PORT }}
          TODOS_API_PORT: ${{ vars.TODOS_API_PORT }}
          USERS_API_PORT: ${{ vars.USERS_API_PORT }}
          FRONTEND_PORT: ${{ vars.FRONTEND_PORT }}
          REDIS_HOST: ${{ vars.REDIS_HOST }}
          REDIS_PORT_TODOS: ${{ vars.REDIS_PORT_TODOS }}
          REDIS_PORT_LOG: ${{ vars.REDIS_PORT_LOG }}
          REDIS_CHANNEL: ${{ vars.REDIS_CHANNEL }}
          ZIPKIN_HOST: ${{ vars.ZIPKIN_HOST }}
          ZIPKIN_PORT: ${{ vars.ZIPKIN_PORT }}
          ZIPKIN_URL: ${{ vars.ZIPKIN_URL }}
          USERS_API_URL: ${{ vars.USERS_API_URL }}
        run: |
          echo "Rebuilding frontend with real Azure IP: $AZURE_IP"
          ACR_NAME="msworkshop1devacr"
          ACR_LOGIN_SERVER=$ACR_NAME.azurecr.io

          # Rebuild frontend with the real IP
          docker build -t frontend:latest ./microservices/frontend \
            --build-arg JWT_SECRET=$JWT_SECRET \
            --build-arg AZURE_IP=$AZURE_IP \
            --build-arg AUTH_API_PORT=$AUTH_API_PORT \
            --build-arg TODOS_API_PORT=$TODOS_API_PORT \
            --build-arg USERS_API_PORT=$USERS_API_PORT \
            --build-arg FRONTEND_PORT=$FRONTEND_PORT \
            --build-arg REDIS_HOST=$REDIS_HOST \
            --build-arg REDIS_PORT_TODOS=$REDIS_PORT_TODOS \
            --build-arg REDIS_PORT_LOG=$REDIS_PORT_LOG \
            --build-arg REDIS_CHANNEL=$REDIS_CHANNEL \
            --build-arg ZIPKIN_HOST=$ZIPKIN_HOST \
            --build-arg ZIPKIN_PORT=$ZIPKIN_PORT \
            --build-arg ZIPKIN_URL=$ZIPKIN_URL \
            --build-arg USERS_API_URL=$USERS_API_URL

          docker tag frontend:latest $ACR_LOGIN_SERVER/frontend:latest
          docker push $ACR_LOGIN_SERVER/frontend:latest

          # Restart frontend deployment to use new image
          kubectl rollout restart deployment/frontend -n default

      - name: Check Deployment Status
        run: |
          echo "External IP obtained: $AZURE_IP"
          kubectl get pods
          kubectl get services
          kubectl get deployments
          echo "=== Frontend URLs ==="
          echo "Frontend: http://$AZURE_IP"
          echo "Auth API: http://$AZURE_IP/auth-api"
          echo "Todos API: http://$AZURE_IP/todos-api"
